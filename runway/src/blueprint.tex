\documentclass{article}

\input{../../.lake/build/dressed/library/SBSTest.tex}

\usepackage{amsmath, amsthm, amssymb}
\usepackage{hyperref}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{axiom}{Axiom}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{corollary}{Corollary}[section]

\title{SBS-Test: Status Demo}
\author{Side-By-Side Blueprint Project}

\newcommand{\N}{\mathbb{N}}

\begin{document}
\maketitle

\chapter{Introduction}

This minimal test project demonstrates all features of the Side-by-Side Blueprint:
\begin{itemize}
\item All 6 node status types in the dependency graph
\item Disconnected component detection (the cycle is isolated)
\item Cycle detection (cycle\_a and cycle\_b form a mutual dependency)
\item Dashboard features (key theorems, messages, blocked, issues, debt, misc)
\end{itemize}

\chapter{Main Graph: Status Types}

This chapter demonstrates the 6 node status types with a tree-structured dependency graph
containing 13 connected nodes.

\section{Base Axiom}

A base axiom with no Lean code (notReady status by default).

\begin{axiom}[base\_axiom]
\label{base_axiom}
A base axiom with no Lean code (notReady status).
\end{axiom}

\section{Foundation}

Foundation lemma, manually marked notReady.

\inputleannode{foundation}

\section{Ready Status}

Two theorems marked as ready to formalize.

\inputleannode{ready_to_prove}

\inputleannode{another_ready}

\section{Sorry Status}

Two theorems with incomplete proofs (sorry).

\inputleannode{has_sorry}

\inputleannode{also_sorry}

\section{Proven Status}

Three theorems with complete proofs.

\inputleannode{proven_leaf}

\inputleannode{proven_mid}

\inputleannode{proven_chain}

\section{Fully Proven Chain}

Three theorems forming a fully proven dependency chain.

\inputleannode{fully_chain_1}

\inputleannode{fully_chain_2}

\inputleannode{fully_chain_3}

\section{Mathlib Ready}

A theorem ready for mathlib.

\inputleannode{mathlib_theorem}

\chapter{Validation Test Cases}

These nodes test the graph validation features.

\section{Disconnected Cycle}

These two nodes form a cycle AND are disconnected from the main graph.
This tests both cycle detection and disconnected component detection.

\inputleannode{cycle_a}

\inputleannode{cycle_b}

\chapter{Module Reference Test}

This chapter tests the \texttt{\textbackslash inputleanmodule\{ModuleName\}} command,
which imports all blueprinted declarations from a Lean module at once,
as opposed to referencing them individually with \texttt{\textbackslash inputleannode\{label\}}.

\section{All Declarations from Module}

The following declarations are imported via \texttt{\textbackslash inputleanmodule\{SBSTest.ModuleRefTest\}}:

\inputleanmodule{SBSTest.ModuleRefTest}

\chapter{Bracket Highlighting Demo}

This chapter demonstrates the rainbow bracket highlighting feature.
Each nesting level of brackets gets a different color (cycling through 6 colors),
making it easier to match opening and closing brackets in complex expressions.

\section{Nested Parentheses}

A basic example with 3 levels of nested parentheses.

\inputleannode{bracket:nested}

\section{Mixed Bracket Types}

Demonstrates parentheses and function application.

\inputleannode{bracket:function}

\section{Type Brackets}

Shows implicit type parameters using curly braces.

\inputleannode{bracket:types}

\section{Deep Nesting (8 Levels)}

Tests that bracket colors wrap around correctly after 6 colors.
Level 7 should use color 1 again, level 8 should use color 2.

\inputleannode{bracket:deep}

\section{Mixed Deep Nesting}

Complex expression mixing all bracket types at various depths.

\inputleannode{bracket:mixed_deep}

\section{All Bracket Types}

Combines parentheses, square brackets, and curly braces in realistic code.

\inputleannode{bracket:complex}

\section{Realistic Function}

A more realistic function demonstrating comments and brackets together.

\inputleannode{bracket:realistic}

\section{Extreme Nesting (10 Levels)}

Stress test with 10 levels of bracket nesting to verify wrap-around works
for two complete color cycles plus extra.

\inputleannode{bracket:extreme}

\section{Tactic-Mode Proofs}

Multi-step tactic proofs demonstrating tactic state toggles.

\inputleannode{bracket:nat_add_comm_tactic}

\inputleannode{bracket:list_length_append_tactic}

\chapter{Statement Attribute Demo}

This chapter demonstrates attribute-based LaTeX authoring using
\texttt{@[blueprint]} fields: \texttt{statement}, \texttt{above},
\texttt{below}, and \texttt{proof}.

\section{Basic Statements}

The \texttt{(statement := /-- ... -/)} syntax embeds TeX directly
in the attribute. The \texttt{above} and \texttt{below} fields add
contextual paragraphs around the formal statement.

\inputleannode{attr_demo}

\inputleannode{delim_block_demo}

\inputleannode{delim_line_demo}

\section{Logic Examples}

These declarations form a dependency chain demonstrating how
\texttt{uses} connects nodes in the graph.

\inputleannode{attr_logic}

\inputleannode{delim_block_dne}

\inputleannode{delim_line_id}

\chapter{Security Test}

This chapter tests XSS prevention by using malicious-looking input values
in the blueprint attribute options. All script tags and HTML should be
escaped in the output.

\section{XSS Attack Vectors}

These theorems test various XSS attack vectors in user-controlled fields.
If the security hardening is working, you should see escaped HTML text
(like \texttt{\&lt;script\&gt;}) instead of executed JavaScript.

\inputleannode{xss_title}

\inputleannode{xss_message}

\inputleannode{xss_blocked}

\inputleannode{xss_issue}

\inputleannode{xss_debt}

\inputleannode{xss_misc}

\inputleannode{xss_label}

\inputleannode{xss_quotes}

\end{document}
